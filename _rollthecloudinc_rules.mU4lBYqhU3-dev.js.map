{
  "version": 3,
  "sources": ["../../@rollthecloudinc/rules/fesm2022/rollthecloudinc-rules.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { NgModule, Injectable } from '@angular/core';\nimport { AttributeTypes } from '@rollthecloudinc/attributes';\nimport * as jre from 'json-rules-engine';\nimport { Observable } from 'rxjs';\nimport { take, map, tap, switchMap } from 'rxjs/operators';\nimport * as uuid from 'uuid';\nimport * as i2 from '@rollthecloudinc/context';\nclass RulesModule {\n  static {\n    this.\u0275fac = function RulesModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RulesModule)();\n    };\n  }\n  static {\n    this.\u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n      type: RulesModule\n    });\n  }\n  static {\n    this.\u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.\u0275setClassMetadata(RulesModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [],\n      imports: [],\n      exports: []\n    }]\n  }], null, null);\n})();\nclass RulesParserService {\n  constructor() {\n    this.operatorsMap = new Map([['=', 'equal'], ['!=', 'notEqual']]);\n  }\n  buildFields(obj, prefix = '') {\n    const fields = new Map();\n    this.genericFields(obj, fields, prefix, 0);\n    return fields;\n  }\n  attributeFields(settings, fields, prefix, level) {\n    settings.forEach((s, i) => {\n      if (s.name !== 'widget') {\n        for (const prop in s) {\n          if (s.type === AttributeTypes.Complex || prop === 'attributes' && s.attributes && s.attributes.length > 0) {\n            if (s.type === AttributeTypes.Complex) {\n              this.attributeFields(s.attributes, fields, `${prefix}`, level + 1);\n            } else {\n              this.attributeFields(s.attributes, fields, `${prefix}.${s.name}`, level + 1);\n            }\n          } else if (prop !== 'attributes') {\n            if (prop === s.name) {\n              // fields.set(`${prefix}.${prop}`, { name: `${prefix}.${prop}`, type: this.resolveAttributeType(s[prop].type), defaultValue: s[prop] });\n              fields.set(`${prefix}.${prop}`, {\n                name: `${prefix}.${prop}`,\n                type: this.resolveAttributeType(s.type),\n                defaultValue: s[prop]\n              });\n            } else {\n              // fields.set(`${prefix}.${s.name}.${prop}`, { name: `${prefix}.${s.name}.${prop}`, type: this.resolveAttributeType(s[prop].type), defaultValue: s[prop] });\n              fields.set(`${prefix}.${s.name}.${prop}`, {\n                name: `${prefix}.${s.name}.${prop}`,\n                type: this.resolveAttributeType(s.type),\n                defaultValue: s[prop]\n              });\n            }\n          }\n        }\n      }\n    });\n  }\n  genericFields(obj, fields, prefix, level) {\n    for (const prop in obj) {\n      const type = typeof obj[prop];\n      if (type !== 'object') {\n        fields.set(`${prefix}.${prop}`, {\n          name: `${prefix}.${prop}`,\n          type: this.resolveNativeType(type),\n          defaultValue: obj[prop]\n        });\n      } else if (Array.isArray(obj[prop]) && prop === 'attributes') {\n        this.attributeFields(obj[prop], fields, `${prefix}.${prop}`, level + 1);\n      } else if (Array.isArray(obj[prop])) {\n        var len = obj[prop].length;\n        for (let i = 0; i < len; i++) {\n          this.genericFields(obj[prop][i], fields, `${prefix}.${prop}.${i}`, level + 1);\n        }\n      } else {\n        this.genericFields(obj[prop], fields, `${prefix}.${prop}`, level + 1);\n      }\n    }\n  }\n  /**\n   * Changes commited on 9/12/2021 have potential to break older panel pages that\n   * use context. Although I believe that originally this only worked for one level. Now\n   * it works for nested rules. I also can't recall why the field split was limited\n   * to only 2 items. That might hav just been laziness or there might have been a valid reason for it.\n   * I don't know why that be done instead of using indexOf to make sure the full path is included.\n   */\n  toEngineRule(rule, level = 0) {\n    const conditions = [];\n    if (rule.rules === undefined || !Array.isArray(rule.rules)) {\n      // const [ fact, path ] = (rule as any).field.split('.', 2);\n      const firstDot = rule.field.indexOf('.');\n      const fact = rule.field.substr(0, firstDot);\n      const path = rule.field.substr(firstDot + 1);\n      conditions.push({\n        fact,\n        path: `$.${path}`,\n        operator: this.operatorsMap.get(rule.operator),\n        value: rule.value\n      });\n      return new jre.Rule({\n        conditions: {\n          all: conditions\n        },\n        event: level === 0 ? {\n          type: 'visible'\n        } : undefined\n      });\n    } else {\n      const len = rule.rules.length;\n      for (let i = 0; i < len; i++) {\n        if ('field' in rule.rules[i] && (rule.condition === undefined || rule.condition === null || rule.condition === '')) {\n          // const [ fact, path ] = (rule.rules[i] as NgRule).field.split('.', 2);\n          const firstDot = rule.rules[i].field.indexOf('.');\n          const fact = rule.rules[i].field.substr(0, firstDot);\n          const path = rule.rules[i].field.substr(firstDot + 1);\n          conditions.push({\n            fact,\n            path: `$.${path}`,\n            operator: this.operatorsMap.get(rule.rules[i].operator),\n            value: rule.rules[i].value\n          });\n        } else {\n          const nestedRule = this.toEngineRule(rule.rules[i], level + 1);\n          conditions.push(nestedRule.conditions);\n        }\n      }\n      if (rule.condition === 'and') {\n        return new jre.Rule({\n          conditions: {\n            all: conditions\n          },\n          event: level === 0 ? {\n            type: 'visible'\n          } : undefined\n        });\n      } else {\n        return new jre.Rule({\n          conditions: {\n            any: conditions\n          },\n          event: level === 0 ? {\n            type: 'visible'\n          } : undefined\n        });\n      }\n    }\n  }\n  extractConditions(ngRule, level = 0) {\n    const rule = this.toEngineRule(ngRule);\n    return [...(rule.conditions.any !== undefined ? rule.conditions.any : []), ...(rule.conditions.all !== undefined ? rule.conditions.all : [])];\n  }\n  resolveNativeType(type) {\n    switch (type) {\n      case 'number':\n        return 'number';\n      case 'boolean':\n        return 'boolean';\n      case 'string':\n      default:\n        return 'string';\n    }\n  }\n  resolveAttributeType(type) {\n    switch (type) {\n      case AttributeTypes.Float:\n      case AttributeTypes.Number:\n        return 'number';\n      case AttributeTypes.Bool:\n        return 'boolean';\n      case AttributeTypes.Text:\n      default:\n        return 'string';\n    }\n  }\n  static {\n    this.\u0275fac = function RulesParserService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RulesParserService)();\n    };\n  }\n  static {\n    this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n      token: RulesParserService,\n      factory: RulesParserService.\u0275fac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.\u0275setClassMetadata(RulesParserService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n// import { Rule } from 'json-rules-engine'\nclass RulesResolverService {\n  constructor(rulesParser, inlineContextResolver) {\n    this.rulesParser = rulesParser;\n    this.inlineContextResolver = inlineContextResolver;\n  }\n  evaluate(ngRule, contexts = []) {\n    return this.inlineContextResolver.resolveMerged(contexts, `rules:${uuid.v4()}`).pipe(take(1), map(facts => [{\n      ...facts\n    }, new jre.Engine()]), tap(([_, engine]) => {\n      const rule = this.rulesParser.toEngineRule(ngRule);\n      engine.addRule(rule);\n    }), switchMap(([facts, engine]) => new Observable(obs => {\n      engine.run(facts).then(res => {\n        obs.next(res.events.findIndex(e => e.type === 'visible') > -1);\n        obs.complete();\n      });\n    })));\n    // A bit easier to debug using breakpoints.\n    /*return new Observable<boolean>(obs => {\n      const name = `rules:${uuid.v4()}`;\n      this.inlineContextResolver.resolveMerged(contexts, name).pipe(\n        take(1),\n        map(facts => [{ ...facts }, new Engine()]),\n        tap(([facts, engine]) => {\n          const rule = this.rulesParser.toEngineRule(ngRule);\n          engine.addRule(new Rule({\n            ...rule,\n            onSuccess: () => {\n              obs.next(true);\n              obs.complete();\n            },\n            onFailure: () => {\n              obs.next(false);\n              obs.complete();\n            },\n            name\n          }));\n          engine.run(facts).then(() => {\n            console.log('facts ran!');\n          });;\n        })\n      ).subscribe(() => {\n        console.log(`subscription complete for rule ${name}`);\n      });\n    });*/\n  }\n  static {\n    this.\u0275fac = function RulesResolverService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RulesResolverService)(i0.\u0275\u0275inject(RulesParserService), i0.\u0275\u0275inject(i2.InlineContextResolverService));\n    };\n  }\n  static {\n    this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n      token: RulesResolverService,\n      factory: RulesResolverService.\u0275fac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.\u0275setClassMetadata(RulesResolverService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: RulesParserService\n  }, {\n    type: i2.InlineContextResolverService\n  }], null);\n})();\n\n/*\n * Public API Surface of rules\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RulesModule, RulesParserService, RulesResolverService };\n"],
  "mappings": ";;;;;;;;;;;;AAAA,YAAY,QAAQ;AACpB,SAAS,UAAU,kBAAkB;AACrC,SAAS,sBAAsB;AAC/B,YAAY,SAAS;AAErB,SAAS,MAAM,KAAK,KAAK,iBAAiB;AAE1C,YAAY,QAAQ;AACpB,IAAM,cAAN,MAAM,aAAY;AAAA,EAChB,OAAO;AACL,SAAK,YAAO,SAAS,oBAAoB,mBAAmB;AAC1D,aAAO,KAAK,qBAAqB,cAAa;AAAA,IAChD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,YAAsB,gBAAG,8BAAiB;AAAA,MAC7C,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AAAA,EACA,OAAO;AACL,SAAK,YAAsB,gBAAG,8BAAiB,CAAC,CAAC;AAAA,EACnD;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,0BAAkB,aAAa,CAAC;AAAA,IACpF,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,cAAc,CAAC;AAAA,MACf,SAAS,CAAC;AAAA,MACV,SAAS,CAAC;AAAA,IACZ,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;AACH,IAAM,qBAAN,MAAM,oBAAmB;AAAA,EACvB,cAAc;AACZ,SAAK,eAAe,oBAAI,IAAI,CAAC,CAAC,KAAK,OAAO,GAAG,CAAC,MAAM,UAAU,CAAC,CAAC;AAAA,EAClE;AAAA,EACA,YAAY,KAAK,SAAS,IAAI;AAC5B,UAAM,SAAS,oBAAI,IAAI;AACvB,SAAK,cAAc,KAAK,QAAQ,QAAQ,CAAC;AACzC,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,UAAU,QAAQ,QAAQ,OAAO;AAC/C,aAAS,QAAQ,CAAC,GAAG,MAAM;AACzB,UAAI,EAAE,SAAS,UAAU;AACvB,mBAAW,QAAQ,GAAG;AACpB,cAAI,EAAE,SAAS,eAAe,WAAW,SAAS,gBAAgB,EAAE,cAAc,EAAE,WAAW,SAAS,GAAG;AACzG,gBAAI,EAAE,SAAS,eAAe,SAAS;AACrC,mBAAK,gBAAgB,EAAE,YAAY,QAAQ,GAAG,MAAM,IAAI,QAAQ,CAAC;AAAA,YACnE,OAAO;AACL,mBAAK,gBAAgB,EAAE,YAAY,QAAQ,GAAG,MAAM,IAAI,EAAE,IAAI,IAAI,QAAQ,CAAC;AAAA,YAC7E;AAAA,UACF,WAAW,SAAS,cAAc;AAChC,gBAAI,SAAS,EAAE,MAAM;AAEnB,qBAAO,IAAI,GAAG,MAAM,IAAI,IAAI,IAAI;AAAA,gBAC9B,MAAM,GAAG,MAAM,IAAI,IAAI;AAAA,gBACvB,MAAM,KAAK,qBAAqB,EAAE,IAAI;AAAA,gBACtC,cAAc,EAAE,IAAI;AAAA,cACtB,CAAC;AAAA,YACH,OAAO;AAEL,qBAAO,IAAI,GAAG,MAAM,IAAI,EAAE,IAAI,IAAI,IAAI,IAAI;AAAA,gBACxC,MAAM,GAAG,MAAM,IAAI,EAAE,IAAI,IAAI,IAAI;AAAA,gBACjC,MAAM,KAAK,qBAAqB,EAAE,IAAI;AAAA,gBACtC,cAAc,EAAE,IAAI;AAAA,cACtB,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,cAAc,KAAK,QAAQ,QAAQ,OAAO;AACxC,eAAW,QAAQ,KAAK;AACtB,YAAM,OAAO,OAAO,IAAI,IAAI;AAC5B,UAAI,SAAS,UAAU;AACrB,eAAO,IAAI,GAAG,MAAM,IAAI,IAAI,IAAI;AAAA,UAC9B,MAAM,GAAG,MAAM,IAAI,IAAI;AAAA,UACvB,MAAM,KAAK,kBAAkB,IAAI;AAAA,UACjC,cAAc,IAAI,IAAI;AAAA,QACxB,CAAC;AAAA,MACH,WAAW,MAAM,QAAQ,IAAI,IAAI,CAAC,KAAK,SAAS,cAAc;AAC5D,aAAK,gBAAgB,IAAI,IAAI,GAAG,QAAQ,GAAG,MAAM,IAAI,IAAI,IAAI,QAAQ,CAAC;AAAA,MACxE,WAAW,MAAM,QAAQ,IAAI,IAAI,CAAC,GAAG;AACnC,YAAI,MAAM,IAAI,IAAI,EAAE;AACpB,iBAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,eAAK,cAAc,IAAI,IAAI,EAAE,CAAC,GAAG,QAAQ,GAAG,MAAM,IAAI,IAAI,IAAI,CAAC,IAAI,QAAQ,CAAC;AAAA,QAC9E;AAAA,MACF,OAAO;AACL,aAAK,cAAc,IAAI,IAAI,GAAG,QAAQ,GAAG,MAAM,IAAI,IAAI,IAAI,QAAQ,CAAC;AAAA,MACtE;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,MAAM,QAAQ,GAAG;AAC5B,UAAM,aAAa,CAAC;AACpB,QAAI,KAAK,UAAU,UAAa,CAAC,MAAM,QAAQ,KAAK,KAAK,GAAG;AAE1D,YAAM,WAAW,KAAK,MAAM,QAAQ,GAAG;AACvC,YAAM,OAAO,KAAK,MAAM,OAAO,GAAG,QAAQ;AAC1C,YAAM,OAAO,KAAK,MAAM,OAAO,WAAW,CAAC;AAC3C,iBAAW,KAAK;AAAA,QACd;AAAA,QACA,MAAM,KAAK,IAAI;AAAA,QACf,UAAU,KAAK,aAAa,IAAI,KAAK,QAAQ;AAAA,QAC7C,OAAO,KAAK;AAAA,MACd,CAAC;AACD,aAAO,IAAQ,SAAK;AAAA,QAClB,YAAY;AAAA,UACV,KAAK;AAAA,QACP;AAAA,QACA,OAAO,UAAU,IAAI;AAAA,UACnB,MAAM;AAAA,QACR,IAAI;AAAA,MACN,CAAC;AAAA,IACH,OAAO;AACL,YAAM,MAAM,KAAK,MAAM;AACvB,eAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,YAAI,WAAW,KAAK,MAAM,CAAC,MAAM,KAAK,cAAc,UAAa,KAAK,cAAc,QAAQ,KAAK,cAAc,KAAK;AAElH,gBAAM,WAAW,KAAK,MAAM,CAAC,EAAE,MAAM,QAAQ,GAAG;AAChD,gBAAM,OAAO,KAAK,MAAM,CAAC,EAAE,MAAM,OAAO,GAAG,QAAQ;AACnD,gBAAM,OAAO,KAAK,MAAM,CAAC,EAAE,MAAM,OAAO,WAAW,CAAC;AACpD,qBAAW,KAAK;AAAA,YACd;AAAA,YACA,MAAM,KAAK,IAAI;AAAA,YACf,UAAU,KAAK,aAAa,IAAI,KAAK,MAAM,CAAC,EAAE,QAAQ;AAAA,YACtD,OAAO,KAAK,MAAM,CAAC,EAAE;AAAA,UACvB,CAAC;AAAA,QACH,OAAO;AACL,gBAAM,aAAa,KAAK,aAAa,KAAK,MAAM,CAAC,GAAG,QAAQ,CAAC;AAC7D,qBAAW,KAAK,WAAW,UAAU;AAAA,QACvC;AAAA,MACF;AACA,UAAI,KAAK,cAAc,OAAO;AAC5B,eAAO,IAAQ,SAAK;AAAA,UAClB,YAAY;AAAA,YACV,KAAK;AAAA,UACP;AAAA,UACA,OAAO,UAAU,IAAI;AAAA,YACnB,MAAM;AAAA,UACR,IAAI;AAAA,QACN,CAAC;AAAA,MACH,OAAO;AACL,eAAO,IAAQ,SAAK;AAAA,UAClB,YAAY;AAAA,YACV,KAAK;AAAA,UACP;AAAA,UACA,OAAO,UAAU,IAAI;AAAA,YACnB,MAAM;AAAA,UACR,IAAI;AAAA,QACN,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EACA,kBAAkB,QAAQ,QAAQ,GAAG;AACnC,UAAM,OAAO,KAAK,aAAa,MAAM;AACrC,WAAO,CAAC,GAAI,KAAK,WAAW,QAAQ,SAAY,KAAK,WAAW,MAAM,CAAC,GAAI,GAAI,KAAK,WAAW,QAAQ,SAAY,KAAK,WAAW,MAAM,CAAC,CAAE;AAAA,EAC9I;AAAA,EACA,kBAAkB,MAAM;AACtB,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EACA,qBAAqB,MAAM;AACzB,YAAQ,MAAM;AAAA,MACZ,KAAK,eAAe;AAAA,MACpB,KAAK,eAAe;AAClB,eAAO;AAAA,MACT,KAAK,eAAe;AAClB,eAAO;AAAA,MACT,KAAK,eAAe;AAAA,MACpB;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,YAAO,SAAS,2BAA2B,mBAAmB;AACjE,aAAO,KAAK,qBAAqB,qBAAoB;AAAA,IACvD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,aAAuB,gBAAG,gCAAmB;AAAA,MAChD,OAAO;AAAA,MACP,SAAS,oBAAmB;AAAA,MAC5B,YAAY;AAAA,IACd,CAAC;AAAA,EACH;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,0BAAkB,oBAAoB,CAAC;AAAA,IAC3F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,YAAY;AAAA,IACd,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,CAAC,GAAG,IAAI;AACpB,GAAG;AAGH,IAAM,uBAAN,MAAM,sBAAqB;AAAA,EACzB,YAAY,aAAa,uBAAuB;AAC9C,SAAK,cAAc;AACnB,SAAK,wBAAwB;AAAA,EAC/B;AAAA,EACA,SAAS,QAAQ,WAAW,CAAC,GAAG;AAC9B,WAAO,KAAK,sBAAsB,cAAc,UAAU,SAAc,WAAG,CAAC,EAAE,EAAE,KAAK,KAAK,CAAC,GAAG,IAAI,WAAS,CAAC,mBACvG,QACF,IAAQ,WAAO,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM;AAC1C,YAAM,OAAO,KAAK,YAAY,aAAa,MAAM;AACjD,aAAO,QAAQ,IAAI;AAAA,IACrB,CAAC,GAAG,UAAU,CAAC,CAAC,OAAO,MAAM,MAAM,IAAI,WAAW,SAAO;AACvD,aAAO,IAAI,KAAK,EAAE,KAAK,SAAO;AAC5B,YAAI,KAAK,IAAI,OAAO,UAAU,OAAK,EAAE,SAAS,SAAS,IAAI,EAAE;AAC7D,YAAI,SAAS;AAAA,MACf,CAAC;AAAA,IACH,CAAC,CAAC,CAAC;AAAA,EA6BL;AAAA,EACA,OAAO;AACL,SAAK,YAAO,SAAS,6BAA6B,mBAAmB;AACnE,aAAO,KAAK,qBAAqB,uBAAyB,sBAAS,kBAAkB,GAAM,sBAAY,+BAA4B,CAAC;AAAA,IACtI;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,aAAuB,gBAAG,gCAAmB;AAAA,MAChD,OAAO;AAAA,MACP,SAAS,sBAAqB;AAAA,MAC9B,YAAY;AAAA,IACd,CAAC;AAAA,EACH;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,0BAAkB,sBAAsB,CAAC;AAAA,IAC7F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,YAAY;AAAA,IACd,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,CAAC;AAAA,IACT,MAAM;AAAA,EACR,GAAG;AAAA,IACD,MAAS;AAAA,EACX,CAAC,GAAG,IAAI;AACV,GAAG;",
  "names": []
}
