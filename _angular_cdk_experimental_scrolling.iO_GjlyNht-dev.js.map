{
  "version": 3,
  "sources": ["../../@angular/cdk-experimental/fesm2022/scrolling.mjs"],
  "sourcesContent": ["import { coerceNumberProperty } from '@angular/cdk/coercion';\nimport { VIRTUAL_SCROLL_STRATEGY } from '@angular/cdk/scrolling';\nimport * as i0 from '@angular/core';\nimport { forwardRef, Directive, Input, NgModule } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n/**\n * A class that tracks the size of items that have been seen and uses it to estimate the average\n * item size.\n */\nclass ItemSizeAverager {\n  /** The total amount of weight behind the current average. */\n  _totalWeight = 0;\n  /** The current average item size. */\n  _averageItemSize;\n  /** The default size to use for items when no data is available. */\n  _defaultItemSize;\n  /** @param defaultItemSize The default size to use for items when no data is available. */\n  constructor(defaultItemSize = 50) {\n    this._defaultItemSize = defaultItemSize;\n    this._averageItemSize = defaultItemSize;\n  }\n  /** Returns the average item size. */\n  getAverageItemSize() {\n    return this._averageItemSize;\n  }\n  /**\n   * Adds a measurement sample for the estimator to consider.\n   * @param range The measured range.\n   * @param size The measured size of the given range in pixels.\n   */\n  addSample(range, size) {\n    const newTotalWeight = this._totalWeight + range.end - range.start;\n    if (newTotalWeight) {\n      const newAverageItemSize = (size + this._averageItemSize * this._totalWeight) / newTotalWeight;\n      if (newAverageItemSize) {\n        this._averageItemSize = newAverageItemSize;\n        this._totalWeight = newTotalWeight;\n      }\n    }\n  }\n  /** Resets the averager. */\n  reset() {\n    this._averageItemSize = this._defaultItemSize;\n    this._totalWeight = 0;\n  }\n}\n/** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\nclass AutoSizeVirtualScrollStrategy {\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  scrolledIndexChange = new Observable(() => {\n    // TODO(mmalerba): Implement.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw Error('cdk-virtual-scroll: scrolledIndexChange is currently not supported for the' + ' autosize scroll strategy');\n    }\n  });\n  /** The attached viewport. */\n  _viewport = null;\n  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\n  _minBufferPx;\n  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\n  _maxBufferPx;\n  /** The estimator used to estimate the size of unseen items. */\n  _averager;\n  /** The last measured scroll offset of the viewport. */\n  _lastScrollOffset;\n  /** The last measured size of the rendered content in the viewport. */\n  _lastRenderedContentSize;\n  /** The last measured size of the rendered content in the viewport. */\n  _lastRenderedContentOffset;\n  /**\n   * The number of consecutive cycles where removing extra items has failed. Failure here means that\n   * we estimated how many items we could safely remove, but our estimate turned out to be too much\n   * and it wasn't safe to remove that many elements.\n   */\n  _removalFailures = 0;\n  /**\n   * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n   *     If the amount of buffer dips below this number, more items will be rendered.\n   * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\n   *     If the actual amount turns out to be less it will not necessarily trigger an additional\n   *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n   * @param averager The averager used to estimate the size of unseen items.\n   */\n  constructor(minBufferPx, maxBufferPx, averager = new ItemSizeAverager()) {\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n    this._averager = averager;\n  }\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport) {\n    this._averager.reset();\n    this._viewport = viewport;\n    this._renderContentForCurrentOffset();\n  }\n  /** Detaches this scroll strategy from the currently attached viewport. */\n  detach() {\n    this._viewport = null;\n  }\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentScrolled() {\n    if (this._viewport) {\n      this._updateRenderedContentAfterScroll();\n    }\n  }\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onDataLengthChanged() {\n    if (this._viewport) {\n      this._renderContentForCurrentOffset();\n      this._checkRenderedContentSize();\n    }\n  }\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentRendered() {\n    if (this._viewport) {\n      this._checkRenderedContentSize();\n    }\n  }\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onRenderedOffsetChanged() {\n    if (this._viewport) {\n      this._checkRenderedContentOffset();\n    }\n  }\n  /** Scroll to the offset for the given index. */\n  scrollToIndex() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      // TODO(mmalerba): Implement.\n      throw Error('cdk-virtual-scroll: scrollToIndex is currently not supported for the autosize' + ' scroll strategy');\n    }\n  }\n  /**\n   * Update the buffer parameters.\n   * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\n   *     pixels).\n   */\n  updateBufferSize(minBufferPx, maxBufferPx) {\n    if (maxBufferPx < minBufferPx) {\n      throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n    }\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n  }\n  /** Update the rendered content after the user scrolls. */\n  _updateRenderedContentAfterScroll() {\n    const viewport = this._viewport;\n    // The current scroll offset.\n    const scrollOffset = viewport.measureScrollOffset();\n    // The delta between the current scroll offset and the previously recorded scroll offset.\n    let scrollDelta = scrollOffset - this._lastScrollOffset;\n    // The magnitude of the scroll delta.\n    let scrollMagnitude = Math.abs(scrollDelta);\n    // The currently rendered range.\n    const renderedRange = viewport.getRenderedRange();\n    // If we're scrolling toward the top, we need to account for the fact that the predicted amount\n    // of content and the actual amount of scrollable space may differ. We address this by slowly\n    // correcting the difference on each scroll event.\n    let offsetCorrection = 0;\n    if (scrollDelta < 0) {\n      // The content offset we would expect based on the average item size.\n      const predictedOffset = renderedRange.start * this._averager.getAverageItemSize();\n      // The difference between the predicted size of the un-rendered content at the beginning and\n      // the actual available space to scroll over. We need to reduce this to zero by the time the\n      // user scrolls to the top.\n      // - 0 indicates that the predicted size and available space are the same.\n      // - A negative number that the predicted size is smaller than the available space.\n      // - A positive number indicates the predicted size is larger than the available space\n      const offsetDifference = predictedOffset - this._lastRenderedContentOffset;\n      // The amount of difference to correct during this scroll event. We calculate this as a\n      // percentage of the total difference based on the percentage of the distance toward the top\n      // that the user scrolled.\n      offsetCorrection = Math.round(offsetDifference * Math.max(0, Math.min(1, scrollMagnitude / (scrollOffset + scrollMagnitude))));\n      // Based on the offset correction above, we pretend that the scroll delta was bigger or\n      // smaller than it actually was, this way we can start to eliminate the difference.\n      scrollDelta = scrollDelta - offsetCorrection;\n      scrollMagnitude = Math.abs(scrollDelta);\n    }\n    // The current amount of buffer past the start of the viewport.\n    const startBuffer = this._lastScrollOffset - this._lastRenderedContentOffset;\n    // The current amount of buffer past the end of the viewport.\n    const endBuffer = this._lastRenderedContentOffset + this._lastRenderedContentSize - (this._lastScrollOffset + viewport.getViewportSize());\n    // The amount of unfilled space that should be filled on the side the user is scrolling toward\n    // in order to safely absorb the scroll delta.\n    const underscan = scrollMagnitude + this._minBufferPx - (scrollDelta < 0 ? startBuffer : endBuffer);\n    // Check if there's unfilled space that we need to render new elements to fill.\n    if (underscan > 0) {\n      // Check if the scroll magnitude was larger than the viewport size. In this case the user\n      // won't notice a discontinuity if we just jump to the new estimated position in the list.\n      // However, if the scroll magnitude is smaller than the viewport the user might notice some\n      // jitteriness if we just jump to the estimated position. Instead we make sure to scroll by\n      // the same number of pixels as the scroll magnitude.\n      if (scrollMagnitude >= viewport.getViewportSize()) {\n        this._renderContentForCurrentOffset();\n      } else {\n        // The number of new items to render on the side the user is scrolling towards. Rather than\n        // just filling the underscan space, we actually fill enough to have a buffer size of\n        // `maxBufferPx`. This gives us a little wiggle room in case our item size estimate is off.\n        const addItems = Math.max(0, Math.ceil((underscan - this._minBufferPx + this._maxBufferPx) / this._averager.getAverageItemSize()));\n        // The amount of filled space beyond what is necessary on the side the user is scrolling\n        // away from.\n        const overscan = (scrollDelta < 0 ? endBuffer : startBuffer) - this._minBufferPx + scrollMagnitude;\n        // The number of currently rendered items to remove on the side the user is scrolling away\n        // from. If removal has failed in recent cycles we are less aggressive in how much we try to\n        // remove.\n        const unboundedRemoveItems = Math.floor(overscan / this._averager.getAverageItemSize() / (this._removalFailures + 1));\n        const removeItems = Math.min(renderedRange.end - renderedRange.start, Math.max(0, unboundedRemoveItems));\n        // The new range we will tell the viewport to render. We first expand it to include the new\n        // items we want rendered, we then contract the opposite side to remove items we no longer\n        // want rendered.\n        const range = this._expandRange(renderedRange, scrollDelta < 0 ? addItems : 0, scrollDelta > 0 ? addItems : 0);\n        if (scrollDelta < 0) {\n          range.end = Math.max(range.start + 1, range.end - removeItems);\n        } else {\n          range.start = Math.min(range.end - 1, range.start + removeItems);\n        }\n        // The new offset we want to set on the rendered content. To determine this we measure the\n        // number of pixels we removed and then adjust the offset to the start of the rendered\n        // content or to the end of the rendered content accordingly (whichever one doesn't require\n        // that the newly added items to be rendered to calculate.)\n        let contentOffset;\n        let contentOffsetTo;\n        if (scrollDelta < 0) {\n          let removedSize = viewport.measureRangeSize({\n            start: range.end,\n            end: renderedRange.end\n          });\n          // Check that we're not removing too much.\n          if (removedSize <= overscan) {\n            contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize - removedSize;\n            this._removalFailures = 0;\n          } else {\n            // If the removal is more than the overscan can absorb just undo it and record the fact\n            // that the removal failed so we can be less aggressive next time.\n            range.end = renderedRange.end;\n            contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize;\n            this._removalFailures++;\n          }\n          contentOffsetTo = 'to-end';\n        } else {\n          const removedSize = viewport.measureRangeSize({\n            start: renderedRange.start,\n            end: range.start\n          });\n          // Check that we're not removing too much.\n          if (removedSize <= overscan) {\n            contentOffset = this._lastRenderedContentOffset + removedSize;\n            this._removalFailures = 0;\n          } else {\n            // If the removal is more than the overscan can absorb just undo it and record the fact\n            // that the removal failed so we can be less aggressive next time.\n            range.start = renderedRange.start;\n            contentOffset = this._lastRenderedContentOffset;\n            this._removalFailures++;\n          }\n          contentOffsetTo = 'to-start';\n        }\n        // Set the range and offset we calculated above.\n        viewport.setRenderedRange(range);\n        viewport.setRenderedContentOffset(contentOffset + offsetCorrection, contentOffsetTo);\n      }\n    } else if (offsetCorrection) {\n      // Even if the rendered range didn't change, we may still need to adjust the content offset to\n      // simulate scrolling slightly slower or faster than the user actually scrolled.\n      viewport.setRenderedContentOffset(this._lastRenderedContentOffset + offsetCorrection);\n    }\n    // Save the scroll offset to be compared to the new value on the next scroll event.\n    this._lastScrollOffset = scrollOffset;\n  }\n  /**\n   * Checks the size of the currently rendered content and uses it to update the estimated item size\n   * and estimated total content size.\n   */\n  _checkRenderedContentSize() {\n    const viewport = this._viewport;\n    this._lastRenderedContentSize = viewport.measureRenderedContentSize();\n    this._averager.addSample(viewport.getRenderedRange(), this._lastRenderedContentSize);\n    this._updateTotalContentSize(this._lastRenderedContentSize);\n  }\n  /** Checks the currently rendered content offset and saves the value for later use. */\n  _checkRenderedContentOffset() {\n    const viewport = this._viewport;\n    this._lastRenderedContentOffset = viewport.getOffsetToRenderedContentStart();\n  }\n  /**\n   * Recalculates the rendered content based on our estimate of what should be shown at the current\n   * scroll offset.\n   */\n  _renderContentForCurrentOffset() {\n    const viewport = this._viewport;\n    const scrollOffset = viewport.measureScrollOffset();\n    this._lastScrollOffset = scrollOffset;\n    this._removalFailures = 0;\n    const itemSize = this._averager.getAverageItemSize();\n    const firstVisibleIndex = Math.min(viewport.getDataLength() - 1, Math.floor(scrollOffset / itemSize));\n    const bufferSize = Math.ceil(this._maxBufferPx / itemSize);\n    const range = this._expandRange(this._getVisibleRangeForIndex(firstVisibleIndex), bufferSize, bufferSize);\n    viewport.setRenderedRange(range);\n    viewport.setRenderedContentOffset(itemSize * range.start);\n  }\n  // TODO: maybe move to base class, can probably share with fixed size strategy.\n  /**\n   * Gets the visible range of data for the given start index. If the start index is too close to\n   * the end of the list it may be backed up to ensure the estimated size of the range is enough to\n   * fill the viewport.\n   * Note: must not be called if `this._viewport` is null\n   * @param startIndex The index to start the range at\n   * @return a range estimated to be large enough to fill the viewport when rendered.\n   */\n  _getVisibleRangeForIndex(startIndex) {\n    const viewport = this._viewport;\n    const range = {\n      start: startIndex,\n      end: startIndex + Math.ceil(viewport.getViewportSize() / this._averager.getAverageItemSize())\n    };\n    const extra = range.end - viewport.getDataLength();\n    if (extra > 0) {\n      range.start = Math.max(0, range.start - extra);\n    }\n    return range;\n  }\n  // TODO: maybe move to base class, can probably share with fixed size strategy.\n  /**\n   * Expand the given range by the given amount in either direction.\n   * Note: must not be called if `this._viewport` is null\n   * @param range The range to expand\n   * @param expandStart The number of items to expand the start of the range by.\n   * @param expandEnd The number of items to expand the end of the range by.\n   * @return The expanded range.\n   */\n  _expandRange(range, expandStart, expandEnd) {\n    const viewport = this._viewport;\n    const start = Math.max(0, range.start - expandStart);\n    const end = Math.min(viewport.getDataLength(), range.end + expandEnd);\n    return {\n      start,\n      end\n    };\n  }\n  /** Update the viewport's total content size. */\n  _updateTotalContentSize(renderedContentSize) {\n    const viewport = this._viewport;\n    const renderedRange = viewport.getRenderedRange();\n    const totalSize = renderedContentSize + (viewport.getDataLength() - (renderedRange.end - renderedRange.start)) * this._averager.getAverageItemSize();\n    viewport.setTotalContentSize(totalSize);\n  }\n}\n/**\n * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\n * `AutoSizeVirtualScrollStrategy` from the given directive.\n * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\n *     `AutoSizeVirtualScrollStrategy` from.\n */\nfunction _autoSizeVirtualScrollStrategyFactory(autoSizeDir) {\n  return autoSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports unknown or dynamic size items. */\nclass CdkAutoSizeVirtualScroll {\n  /**\n   * The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n   */\n  get minBufferPx() {\n    return this._minBufferPx;\n  }\n  set minBufferPx(value) {\n    this._minBufferPx = coerceNumberProperty(value);\n  }\n  _minBufferPx = 100;\n  /**\n   * The number of pixels worth of buffer to shoot for when rendering new items.\n   * If the actual amount turns out to be less it will not necessarily trigger an additional\n   * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n   * Defaults to 200px.\n   */\n  get maxBufferPx() {\n    return this._maxBufferPx;\n  }\n  set maxBufferPx(value) {\n    this._maxBufferPx = coerceNumberProperty(value);\n  }\n  _maxBufferPx = 200;\n  /** The scroll strategy used by this directive. */\n  _scrollStrategy = new AutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx);\n  ngOnChanges() {\n    this._scrollStrategy.updateBufferSize(this.minBufferPx, this.maxBufferPx);\n  }\n  static \u0275fac = function CdkAutoSizeVirtualScroll_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || CdkAutoSizeVirtualScroll)();\n  };\n  static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n    type: CdkAutoSizeVirtualScroll,\n    selectors: [[\"cdk-virtual-scroll-viewport\", \"autosize\", \"\"]],\n    inputs: {\n      minBufferPx: \"minBufferPx\",\n      maxBufferPx: \"maxBufferPx\"\n    },\n    features: [i0.\u0275\u0275ProvidersFeature([{\n      provide: VIRTUAL_SCROLL_STRATEGY,\n      useFactory: _autoSizeVirtualScrollStrategyFactory,\n      deps: [forwardRef(() => CdkAutoSizeVirtualScroll)]\n    }]), i0.\u0275\u0275NgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.\u0275setClassMetadata(CdkAutoSizeVirtualScroll, [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-virtual-scroll-viewport[autosize]',\n      providers: [{\n        provide: VIRTUAL_SCROLL_STRATEGY,\n        useFactory: _autoSizeVirtualScrollStrategyFactory,\n        deps: [forwardRef(() => CdkAutoSizeVirtualScroll)]\n      }]\n    }]\n  }], null, {\n    minBufferPx: [{\n      type: Input\n    }],\n    maxBufferPx: [{\n      type: Input\n    }]\n  });\n})();\nclass ScrollingModule {\n  static \u0275fac = function ScrollingModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ScrollingModule)();\n  };\n  static \u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n    type: ScrollingModule\n  });\n  static \u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.\u0275setClassMetadata(ScrollingModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CdkAutoSizeVirtualScroll],\n      exports: [CdkAutoSizeVirtualScroll]\n    }]\n  }], null, null);\n})();\nexport { AutoSizeVirtualScrollStrategy, CdkAutoSizeVirtualScroll, ItemSizeAverager, ScrollingModule, _autoSizeVirtualScrollStrategyFactory };\n"],
  "mappings": "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",
  "names": []
}
