{
  "version": 3,
  "sources": ["../../@angular/core/fesm2022/signal.mjs", "../../@angular/core/fesm2022/effect.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.3.7\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn = null;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producers: undefined,\n    producersTail: undefined,\n    consumers: undefined,\n    consumersTail: undefined,\n    recomputing: false,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    kind: 'unknown',\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    const prevProducerLink = activeConsumer.producersTail;\n    // If the last producer we accessed is the same as the current one, we can skip adding a new\n    // link\n    if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n        return;\n    }\n    let nextProducerLink = undefined;\n    const isRecomputing = activeConsumer.recomputing;\n    if (isRecomputing) {\n        // If we're incrementally rebuilding the producers list, we want to check if the next producer\n        // in the list is the same as the one we're trying to add.\n        // If the previous producer is defined, then the next producer is just the one that follows it.\n        // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n        nextProducerLink =\n            prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n        if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n            // If the next producer is the same as the one we're trying to add, we can just update the\n            // last read version, update the tail of the producers list of this rerun, and return.\n            activeConsumer.producersTail = nextProducerLink;\n            nextProducerLink.lastReadVersion = node.version;\n            return;\n        }\n    }\n    const prevConsumerLink = node.consumersTail;\n    // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n    // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n    if (prevConsumerLink !== undefined &&\n        prevConsumerLink.consumer === activeConsumer &&\n        // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n        (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n        // If we found an existing link to the consumer we can just return.\n        return;\n    }\n    // If we got here, it means that we need to create a new link between the producer and the consumer.\n    const isLive = consumerIsLive(activeConsumer);\n    const newLink = {\n        producer: node,\n        consumer: activeConsumer,\n        // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n        // the producers list, so that we can destroy all of the old links at once.\n        nextProducer: nextProducerLink,\n        prevConsumer: prevConsumerLink,\n        lastReadVersion: node.version,\n        nextConsumer: undefined,\n    };\n    activeConsumer.producersTail = newLink;\n    if (prevProducerLink !== undefined) {\n        prevProducerLink.nextProducer = newLink;\n    }\n    else {\n        activeConsumer.producers = newLink;\n    }\n    if (isLive) {\n        producerAddLiveConsumer(node, newLink);\n    }\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        producerMarkClean(node);\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.consumers === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n            const consumer = link.consumer;\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context and set\n * it as the active consumer.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    if (node)\n        resetConsumerBeforeComputation(node);\n    return setActiveConsumer(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerBeforeComputation` instead of calling this directly.\n */\nfunction resetConsumerBeforeComputation(node) {\n    node.producersTail = undefined;\n    node.recomputing = true;\n}\n/**\n * Finalize this consumer's state and set previous consumer as the active consumer after a\n * reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (node)\n        finalizeConsumerAfterComputation(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerAfterComputation` instead of calling this directly.\n */\nfunction finalizeConsumerAfterComputation(node) {\n    node.recomputing = false;\n    // We've finished incrementally rebuilding the producers list, now if there are any producers\n    // that are after producersTail, they are stale and should be removed.\n    const producersTail = node.producersTail;\n    let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n    if (toRemove !== undefined) {\n        if (consumerIsLive(node)) {\n            // For each stale link, we first unlink it from the producers list of consumers\n            do {\n                toRemove = producerRemoveLiveConsumerLink(toRemove);\n            } while (toRemove !== undefined);\n        }\n        // Now, we can truncate the producers list to remove all stale links.\n        if (producersTail !== undefined) {\n            producersTail.nextProducer = undefined;\n        }\n        else {\n            node.producers = undefined;\n        }\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    // Poll producers for change.\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n        const producer = link.producer;\n        const seenVersion = link.lastReadVersion;\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        let link = node.producers;\n        while (link !== undefined) {\n            link = producerRemoveLiveConsumerLink(link);\n        }\n    }\n    // Truncate all the linked lists to drop all connection from this node to the graph.\n    node.producers = undefined;\n    node.producersTail = undefined;\n    node.consumers = undefined;\n    node.consumersTail = undefined;\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, link) {\n    const consumersTail = node.consumersTail;\n    const wasLive = consumerIsLive(node);\n    if (consumersTail !== undefined) {\n        link.nextConsumer = consumersTail.nextConsumer;\n        consumersTail.nextConsumer = link;\n    }\n    else {\n        link.nextConsumer = undefined;\n        node.consumers = link;\n    }\n    link.prevConsumer = consumersTail;\n    node.consumersTail = link;\n    if (!wasLive) {\n        for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n            producerAddLiveConsumer(link.producer, link);\n        }\n    }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n    const producer = link.producer;\n    const nextProducer = link.nextProducer;\n    const nextConsumer = link.nextConsumer;\n    const prevConsumer = link.prevConsumer;\n    link.nextConsumer = undefined;\n    link.prevConsumer = undefined;\n    if (nextConsumer !== undefined) {\n        nextConsumer.prevConsumer = prevConsumer;\n    }\n    else {\n        producer.consumersTail = prevConsumer;\n    }\n    if (prevConsumer !== undefined) {\n        prevConsumer.nextConsumer = nextConsumer;\n    }\n    else {\n        producer.consumers = nextConsumer;\n        if (!consumerIsLive(producer)) {\n            let producerLink = producer.producers;\n            while (producerLink !== undefined) {\n                producerLink = producerRemoveLiveConsumerLink(producerLink);\n            }\n        }\n    }\n    return nextProducer;\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n    postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n    const prev = postProducerCreatedFn;\n    postProducerCreatedFn = fn;\n    return prev;\n}\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink, consumer) {\n    const producersTail = consumer.producersTail;\n    if (producersTail !== undefined) {\n        let link = consumer.producers;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === producersTail) {\n                break;\n            }\n            link = link.nextProducer;\n        } while (link !== undefined);\n    }\n    return false;\n}\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'computed',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            let wasEqual = false;\n            try {\n                newValue = node.computation();\n                // We want to mark this node as errored if calling `equal` throws; however, we don't want\n                // to track any reactive reads inside `equal`.\n                setActiveConsumer(null);\n                wasEqual =\n                    oldValue !== UNSET &&\n                        oldValue !== ERRORED &&\n                        newValue !== ERRORED &&\n                        node.equal(oldValue, newValue);\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (wasEqual) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n    throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nfunction createSignal(initialValue, equal) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const getter = (() => signalGetFn(node));\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    const set = (newValue) => signalSetFn(node, newValue);\n    const update = (updateFn) => signalUpdateFn(node, updateFn);\n    return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn(node) {\n    producerAccessed(node);\n    return node.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n    postSignalSetFn?.(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n        kind: 'signal',\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.(node);\n}\n\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, finalizeConsumerAfterComputation, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, resetConsumerBeforeComputation, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };\n\n", "/**\n * @license Angular v20.3.7\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer, consumerPollProducersForChange } from './signal.mjs';\n\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n    const node = Object.create(LINKED_SIGNAL_NODE);\n    node.source = sourceFn;\n    node.computation = computationFn;\n    if (equalityFn != undefined) {\n        node.equal = equalityFn;\n    }\n    const linkedSignalGetter = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    const getter = linkedSignalGetter;\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n    producerUpdateValueVersion(node);\n    signalSetFn(node, newValue);\n    producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n    producerUpdateValueVersion(node);\n    signalUpdateFn(node, updater);\n    producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'linkedSignal',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                const newSourceValue = node.source();\n                const prev = oldValue === UNSET || oldValue === ERRORED\n                    ? undefined\n                    : {\n                        source: node.sourceValue,\n                        value: oldValue,\n                    };\n                newValue = node.computation(newSourceValue, prev);\n                node.sourceValue = newSourceValue;\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nconst BASE_EFFECT_NODE = \n/* @__PURE__ */ (() => ({\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: true,\n    dirty: true,\n    kind: 'effect',\n}))();\nfunction runEffect(node) {\n    node.dirty = false;\n    if (node.version > 0 && !consumerPollProducersForChange(node)) {\n        return;\n    }\n    node.version++;\n    const prevNode = consumerBeforeComputation(node);\n    try {\n        node.cleanup();\n        node.fn();\n    }\n    finally {\n        consumerAfterComputation(node, prevNode);\n    }\n}\n\nexport { BASE_EFFECT_NODE, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, runEffect, untracked };\n\n"],
  "mappings": "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",
  "names": ["link"]
}
